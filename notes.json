[{"created_at":"2018-05-21","tags":[],"title":"Articles","updated_at":"2018-05-21","uuid":"184EC325-776E-41CF-BE49-531C488BAABE","permalink":"/Collection/Articles.html","text":" What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text I/O Models and event loop in javascript "},{"created_at":"2018-05-21","tags":[],"title":"Tools","updated_at":"2018-05-21","uuid":"70C966CE-8E31-4760-97EA-C6BB77A52A7F","permalink":"/Collection/Tools.html","text":" ZoteroJetbrainsVSCodeQuiverTrelloHackmdsharelatexTexStudioIpe "},{"created_at":"2018-01-11","tags":[],"title":"Deep Work","updated_at":"2018-01-11","uuid":"E1A30A68-2B61-4B7C-8215-AE66BE233740","permalink":"/Reading/Deep-Work.html","text":" 亚马逊满99元赚的书，今天到货花了大概四个小时通读了一遍，觉的有不少收获，是个人当前所需要的。全书主要分为两部分： 深度工作理论：深度工作是什么以及深度工作的价值、意义 深度工作准则：进行深度工作的一些准则 在这里我只记下一些重要的笔记，一是通过总结加深下自己的印象，二是以备以后不时之需。注意： 书中有大量\b丰富有趣的事例，这里都略掉了。 有些感想类比是个人所写（大都在以括号标出） 深度工作理论 深度工作与\b浮浅工作 深度工作的特点： 无干扰 使个人认知能力达到极限 创造新的价值，提升技能 难以复制 浮浅工作的特点： 往往有干扰 对认识能力要求不高 没什么价值 容易复制 在极度浮浅的状态下度过足够的时间，将永久性的\b降低自己深度工作的能力 深度工作的价值 信息时代技术更新很快 ➡ 需要快速学习复杂技能 ➡ 需要深度工作 深度工作创造的价值  ➡ 受众可能是无限的  ➡ 极大的提升所获得的奖励 精心挑选深度工作（切换题材从而保持新鲜感？注意力残留？），无法避免的浮浅工作则拆分成小块，在日程的间隙完成（碎片化 vs. 集中化 ？） 三类人 数字科技（智能机器）的发展分化了劳动力市场（数字鸿沟），筛选出了三类获益人： 高级技术工人：擅长使用智能机器进行创造性工作 超级明星：行业翘楚，胜者通吃（因为远程协作，信息\b流通等技术） 所有者：即所谓的资本家，因为劳动力限制得到大为降低 学习复杂技能(不可复制），将技能推向极限来创造实在的价值、成果 培养和深化自己的头脑 深度专注、刻意学习(deliberate practice) 注意力全情投入 （需要深度工作） 适时得到反馈，从而调整方法 专注于某一项特定技能，反复利用同一大脑回路，能有效的固化这项技能 (神经反射，熟能生巧) 高质量产生 ＝ 时间 x 专注度 注意力残留：多任务并行效率低于按次序完成多项任务 （参考js单线程，以前好像在\b知乎上看到有人讲这个） 长时间、无干扰、高度专注于单一任务 注意力管理 集中注意力 vs. 分散注意力 负面恐惧、遗憾 vs. 生活中的美好事物，忽略负面信息  （工作内容） 游手好闲是万恶之源。当你失去关注点时，头脑不会想着生活中的好事，而会纠缠于生活中可能出现的问题 一个人的身体或大脑在自觉努力完成某项艰难且有价值的工作过程中达到极限时，往往是最优体验发生的时候 工作其实比休闲时光更容易带来享受，头脑喜欢挑战 深度工作带来的心流经历可以为你带来深度的满足感 从哲学上看 对工作有某种神圣感（所谓的匠心？），认识到自己工作的意义，能很大程度上得到满足感，从而产生正反馈的激励作用。\b 深度工作准则 准则1：工作要深入 （培养工作的习惯） 欲望是常态，而非个例 工作生活中诱惑是很多的，不要高估自己的抵抗力。意志力是有限的，每次抵抗都会有消耗。 越过良好的意图，在工作生活中加入一些特别设计的惯例和固定程序。以下有6种策略： 首先要选定你的深度哲学：\b 禁欲 （苦修式） 双峰 (例如每年一个月”隐居“，其它时间正常) 节奏：按计划每天特定时候深度工作 新闻记者：由于工作的特殊性，需要随时随地进入深度\b工作 习惯化：将深度工作习惯化（具体的习惯要看个人是否合适） 要有大手笔：适当加大精力、金钱的投入来创造深度工作的良好环境（包括\b物理和心理） 不要独自工作：恰当的加入协作 像经\b商一样执行 关注点放到极端重要的事情上 （你想做的事情越多，完成的事情越少） 抓信引领性指标 （及时反馈，如深度工作的时间） 准备一个醒目的记分板 （记录，提醒，公开化来得到动力） 定期问责 （反馈，调整） 图安逸： 劳逸结合 准则2：拥抱无聊 一旦你适应了分心，你就会迷恋于此 策略：预先\b计划好网络使用时间，在其它时间避免使用网络 使用令人分必的网络本身，并不能减少你大脑专注的能力。实际上减损这种能力的行为是，稍有无聊或有一点点认知上的挑战，就从低刺激、高价值的活动转向高刺激、低价值的活动，这使得你的大脑不能容忍没有新\b奇性的东西 （好像也是在知乎上看到过？） 通过分割网络（相当于分割了分心），减少了自己分心的次数，这样就增强了自己控制注意力的力量。 注意： 即使工作需要大量使用网络，该策略也适用 需要保证彻底地屏藩网络 在工作外也按\b计划使用\b网络，可以进一步提升专注训练的效果 准则3：远离社交媒体 明确在你的职业和个人生活中决定成功与幸福的核心因素，只有一种工\b具对这些因素的实际益处大于实际害处时才选择使用它。 如果你想抵御娱乐网站对你时间和精力的诱惑，那么就给大脑找一些高质量的替代活动 准则4：摒弃浮浅 减少浮浅工作的时间，保持深度工作。 工作时间减少了，但是效率增加了。 一天的每一分钟都要做好计划（太严格了吧？），定量分析每一项活动的深度 （合理的规划） update: 2017-08-24 "},{"created_at":"2017-10-12","tags":[],"title":"Target Series: Summary","updated_at":"2018-01-15","uuid":"02C010C8-9F4F-4DA3-88E8-723CE9D4F661","permalink":"/Cpp/Target-Series-Summary.html","text":" C++ 中有很多难点，包括但不限于： Rvalue reference Templates functions concurrency special member functions Target 系列将以每一个难点为专题来剖析，尽量做到以下几点： 整体方面的完整性 描述各问题的本质 交叉重复内容使用交叉索引 Rvalue reference lvalue/rvalue (const) lvalue/rvalue reference binding std::move, std::forward Templates type deduction instantiation (and function overloading) specialization function function signature specifiers noexcept, explicit, inline, (pure) virtual, noreturn, constexpr, final/override overloading function objects "},{"created_at":"2017-10-11","tags":[],"title":"Target Series: rvalue reference","updated_at":"2018-01-15","uuid":"21C30DB0-F05F-4683-A2CF-45BCC8BCBE2A","permalink":"/Cpp/Target-Series-rvalue-reference.html","text":" lvalues, rvalues lvalues/rvalues are expression types, used to tell compiler whether it’s eligible to be moved from. rvalues are eligible to be moved from, but not guaranted. const rvalues are not eligible. Applying std::move to an (const) object casts it to rvalue. The returned type is (const) rvalue reference. expression types are independent of object types. e.g. a rvalue reference can be either an lvalue or an rvalue (depending on whether it has a name) lvalue(has identity, not movable), xvalue(has identity, movable), rvalue(movable), prvalue (movable, no identity) One way to distinguish between lvalue and rvalue is to consider whether the expression has an “owner”. An “owner” assumes that it can access the expression’s normal value (not destructed). So, a variable name is an “owner” of the object it stands for. A pointer is an “owner” of the object it refers to, etc. An lvalue reference returned by a function has an “owner” (e.g. [] operator), hence it’s an lvalue. An rvalue reference returned by a function doesn’t have an “owner” (e.g. std::move）, hence it’s an rvalue. However, if it’s afterwards binded to a variable name, it has a “owner”. function f(Widget& w){ //... } function f(Widget&& w){ //...    // w is an lvalue, one reason to consider w to be an \"owner\" is that w may be used multiple times in the function body. We need to assume w can access its undestructed value. } Widget w; f(std::move(w));  // std::move(w) is an rvalue, so the move version of f is called reference For effiency, pointers to large objects are used. However, pointers have some annoy features: The syntax is different A pointer may point to different objects A pointer may be nullptr The language mechanism addressing these problems is called a reference. It doesn’t do much harm to think about a reference as a pointer that is dereferenced each time it is used, as long as one remember that a reference isn’t an object. (In some cases, the compiler can optimize away a reference so that there is no object representing that reference at run time) references are implicitly dereferenced. Only in initialization can they be read or written to. Since the goal of an ordinary reference is to mimic the object it reference to, we need to reflect lvalue/rvalue and const/non-const distinctions. There are three kinds of references: lvalue reference: to refer to objects whose value we want to change const reference: to refer to objects whose value we do not want to change (e.g. a constant) rvalue reference: to refer to objects whose value we do not need to preserve after we have used it (e.g. a temporary) The first two are both called lvalue reference. lvalue reference The initializer for a “plain” T& must be an lvalue of type T The initializer for a const T& need not be an lvalue or even of type T. In such cases, a temporary object is created and implicit conversion is applied if necessary and it points to the temporary object. (otherwise it points to the initializer object) rvalue reference An rvalue reference can bind to an rvalue, but not to an lvalue. Both a const lvalue reference and an rvalue reference can bind to an rvalue. However, the purposes will be fundamentally different: We use rvalue references to implement a “destructive read” for optimization of what would otherwise have required a copy. We use a const lvalue reference to prevent modification of an argument. reference binding lvalue references const lvalue reference rvalue references const rvalue references lvalue may binds to #1, #2 const lvalue may binds to #2 rvalue may binds to #3, #4, #2 const rvalue may binds to #4, #2 The binding order is used in function overloading. reference collapse In reference collapse, lvalue reference always wins. Reference to reference can only happen as the result of an alias or a template type argument. (i.e. when the compiler “calculate” a reference type) int && &r - i;  //error Universal reference std::move and std::forward std::move performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything. std::forward casts its argument to an rvalue only if that argument is bound to an rvalue. Neither std::move nor std::forward do anything at runtime. "},{"created_at":"2017-10-11","tags":[],"title":"STL","updated_at":"2017-10-11","uuid":"25C4CE08-3265-495A-8873-B50C751CF7D4","permalink":"/Cpp/STL.html","text":" The C++ standard library contains mainly: Input/Output Containers Iterators Algorithms The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Iterator categories Input iterator (e.g. istream_iterators) Output iterator (e.g. ostream_iterators) Forward iterator (e.g. forward_list::iterators) Bidirectional iterator (e.g. list::iterators) Random-access iterator "},{"created_at":"2018-01-11","tags":[],"title":"Function","updated_at":"2018-01-11","uuid":"39F5F1CD-0AF9-47CF-BB7E-D2D6FF269B2C","permalink":"/Cpp/Function.html","text":" Overloading type of parameters ( conversion ) number of parateters const keyword C++ allows member methods to be overloaded on the basis of const type. Overloading on the basis of const type can be useful when a function return reference or pointer. C++ allows functions to be overloaded on the basis of const-ness of parameters only if the const parameter is a reference or a pointer. Argument Passing Reference Arguments Array Arguments List Arguments Unspecified number of Arguments Default Arguments A general function often needs more arguments than are necessary to handle simple cases. In particular, functions that construct objects (§16.2.5) often provide several options for flexibility. Consider the complex class: class complex { double re, im; public: complex(double r, double i) :re{r}, im{i} {} // construct complex from two scalars complex(double r) :re{r}, im{0} {} // construct complex from one scalar complex() :re{0}, im{0} {} // default complex: {0,0} // ... }; We could deal with the repetitiveness by considering one of the constructors “the real one” and forward to that (§17.4.3): complex(double r, double i) :re{r}, im{i} {} // construct complex from two scalars complex(double r) :complex{2,0} {} // construct complex from one scalar complex() :complex{0,0} {} // default complex: {0,0} However, this can be abbreviated further: complex(double r ={}, double i ={}) :re{r}, im{i} {} // construct complex from two scalars This makes it clear that if a user supplies fewer than the two arguments needed, the default is used. A default argument is type checked at the time of the function declaration and evaluated at the time of the call. (Default arguments that can change value are most often best avoided because they introduce subtle context dependencies.) class X { public: static int def_arg; void f(int =def_arg); // ... }; Default arguments may be provided for trailing arguments only. int f(int, int =0, char* =nullptr);// OK int g(int =0, int =0, char*); // error int h(int =0, int, char* =nullptr);// error A default argument cannot be repeated or changed in a subsequent declaration in the same scope. void f(int x = 7); void f(int = 7); // error: cannot repeat default argument void f(int = 8); // error: different default arguments void g() { void f(int x = 9); // OK: this declaration hides the outer one // ... } "},{"created_at":"2017-10-11","tags":[],"title":"FAQ","updated_at":"2018-01-11","uuid":"525B72C6-36D6-452E-A5FA-65542B412D79","permalink":"/Cpp/FAQ.html","text":" class B{} class D:public B{} //definition of class B and class D are omitted int main(){ B b; D d; return 0; } How does the compiler resolve a function call ? In the following order: name loopup(scope hiding) type check(overload resolving) check accessability check deleted status Are all data members static binded except for those inherited from virtual base classes ? YES. The binding depends only on the type of pointers (or references). Are virtual function tables of base class stored in objects of derived class ? YES. They are stored as data member of base class subobject. (Not accessable through virtual function mechanism of objects of derived class.) Is assignment operator binded staticly? YES. e.g. Assignment operator expects an argument of type const &X b = d;  // OK, slice. Because D can be converted to const& B d = b; // error. B can not be converted to const& D D d1; D d2; B& b_ref = d2; b_ref = d1;  //assignment operator of A is binded. //d2 now contains a mixture of b1 and b2! Pointer to base class can be assigned with pointer to derived class. Vice versa? NO. Pointer to derived class can’t be assigned to pointer to base class object. e.g. B b; B *b_ptr = &b; D *d = b_ptr; // error Does “this” in inherited member function pointer to base subobject? YES. “this” should be readjusted both for virtual and non-virtual function. "},{"created_at":"2017-10-11","tags":[],"title":"Summary","updated_at":"2017-10-11","uuid":"715DD449-B23D-43C4-9406-281EEDD933F8","permalink":"/Cpp/Summary.html","text":" Books and tutorials The Definitive C++ Book Guide and List Accelerated C++ Essential C++ Inside the C++ Object Model The Annotated C++ Reference Manual The C++ Standard (INCITS/ISO/IEC 14882-2011) The C++ Programming Language (Bjarne Stroustrup) Useful references and terms rvalue reference explained copy elision and RVO RVO V.S. std::move copy elision Conditions under which compiler will not define implicits (constructor, destructor, copy constructor, copy assignment) Conditions for automatic generation of special member functions What is object slicing?(answer by splicer) Resource acquisition is initialization (RAII) Named Return Value Optimization (NRVO) Run-Time Type Information (RTTI) const in function overloading ref-qualifier in function overloading Notes rvalue reference notes "},{"created_at":"2017-10-24","tags":[],"title":"mylib","updated_at":"2017-10-24","uuid":"765A343B-793C-44F8-BD75-3D4E26DC1070","permalink":"/Cpp/mylib.html","text":" namespace dujcommon data structure and algorithmsas generic as possible Fibonacci heap/queue  (refer to boost::heap) Fenwich tree graph algorithms "},{"created_at":"2017-10-24","tags":[],"title":"tools","updated_at":"2017-10-24","uuid":"C145A197-A9FB-416E-B948-7150294CFDEB","permalink":"/Cpp/tools.html","text":" Commands1. nm2. c++filt "},{"created_at":"2017-10-14","tags":[],"title":"参考资料","updated_at":"2018-01-15","uuid":"CE044743-5D4C-4B8B-AF2E-F9A2CCC3C6EC","permalink":"/Cpp/参考资料.html","text":" 入门基础 C++ Primer (5th) The C++ Programming Language (4th) 实战技术 Effective C++ Effective Modern C++ Effective STL 中级教程 More Effective C++ Exceptional C++ More Exceptional C++ Exceptional C++ Style C++ Coding Standards C++ Templates "},{"created_at":"2017-10-15","tags":["linkage"],"title":"others","updated_at":"2018-01-11","uuid":"EECD08E7-7580-4505-BCE2-4541B2413422","permalink":"/Cpp/others.html","text":" LLVM (low level virtual machine) 是一系列binary和tools的集合，可以用来构造编译器。clang 是用LLVM 构造的应用于c/c++, objective c/c++等语言的编译器，clang是前端，LLVM是后端。llvm-gcc是一个modified version of gcc，使用了llvm作为后端（而不是gcc的后端），现在已经deprecated.从编译器使用者的角度看，clang基本兼容gcc, 但在诸如compile commands、link、extensions等方面有些小差异。https://clang.llvm.orghttps://gcc.gnu.org/onlinedocs/gcc/index.html C and C++ provide for three levels of linkage:•\tA name with no linkage denotes an entity that can't be referenced via names from anywhere else.• A name with internal linkage denotes an entity that can be referenced via names declared in the same scope or in other scopes of the same translation unit.•\tA name with external linkage denotes an entity that can be referenced via names declared in the same scope or in other scopes of the same translation unit (just as with internal linkage), or additionally in other translation units.Both function and object names can have either internal or external linkage. Object names can also have no linkage. Beyond that, all other names in C have no linkage. In contrast, other names in C++ can have external linkage, including names for classes, enumeration types and constants, namespaces, references, and templates. References and function templates can also have internal linkage. static library vs. dynamic library on windows "},{"created_at":"2018-01-11","tags":[],"title":"Javascript Promise","updated_at":"2018-01-11","uuid":"2F49B56C-D7A1-408E-9A3F-F371DEE7CC27","permalink":"/Web/Javascript-Promise.html","text":" Promise Javascript promise, under the hood. This article illustrate how promise works by writing its own promise library squab. It clearly shows what “promise” generally looks like. A Promise represents a value which may be available now, or in the future, or never. It’s just a syntactical sugar for asynchronous function callback. Promise by 廖雪锋 Promise/A+ The official specification 1. A ‘promise’ is an object or function with a then method whose behavior conforms to this specification. 2. A promise must be in one of three states: pending, fulfilled, or rejected. When pending, a promise: may transition to either the fulfilled or rejected state. When fulfilled, a promise: must not transition to any other state. must have a value, which must not change. When rejected, a promise: must not transition to any other state. must have a reason, which must not change. Here, “must not change” means immutable identity (i.e. ===), but does not imply deep immutability. 3. A promise must provide a then method to access its current or eventual value or reason. A promise’s then method accepts two arguments (both are optional, non-function are ignored): promise.then(onFulfilled, onRejected) then must return a promise 'use strict'; var p1 = new Promise(function (resolve, reject) { console.log('p1 creating...'); //execute immediately reject('rejecting');  //transit to fulfilled resolve('resolving'); //invalid console.log('p1 created'); //execute immediately }); console.log(typeof p1); //object console.log(p1); p1.then(function (result) { console.log(result) }, function (err) { console.log(err) }); output: p1 creating... p1 created object Promise { <rejected> 'rejecting' } rejecting "},{"created_at":"2018-01-11","tags":[],"title":"Javascript Others","updated_at":"2018-01-11","uuid":"5C2FD32D-16D3-4009-83C5-0A4487F683E0","permalink":"/Web/Javascript-Others.html","text":" jquery w3 tutorial underscore "},{"created_at":"2018-01-11","tags":[],"title":"Javascript Object Oriented","updated_at":"2018-01-11","uuid":"665B74B6-94FE-4F45-8993-0E6039C2BC05","permalink":"/Web/Javascript-Object-Oriented.html","text":" Object oriented Object Every variable can be used as a object, except for undefined and null . Even number literal has its dot operation if the dot is not parsed as float point. 2.toString(); // SyntaxError 2..toString(); // valid 2 .toString(); // valid (2).toString(); //valid However, javascript distinguish object data types (including function object and array object) from primary data types (Number, String, …) var a = 3; a.x = 2; //invalid, a.x is undifiend var b = [3, 2]; b.x = 2; //valid function foo(){} foo.x = 2; //valid var c = {} c.x = 2; //valid var s = \"str\"; s.x = 2; //invalid object can be used as hash tables. A property can be accessed in two ways: dot operation and [] operation. They are equivalent, except that [] operation can be used in following two cases while dot operation can’t: set property dynamiclly property name is a not valid variable name Objects created using {} are inherited form Object.prototype. A property can only be deleted using delete operation Usage of this this can only be used inside of function, it always refers to the caller of this function. this may refers to global var x = 1; function test(){ alert(this.x); } test(); // 1 this in constructor function var x = 2; function test(){ this.x = 1; } var o = new test(); alert(x); //2　　 alert(o.x); //1 this in bound function: apply, call var x = 0; function test(){ alert(this.x); } var o = {}; o.x = 1; o.m = test; o.m.apply(); //0 o.m.apply(o); //1 Prototypal inheritance We distinguish __proto__ from prototype Every object (include function object) has an implicit __proto__ property. It is this property that implements prototype chain. function getProperty(obj, prop) { if (obj.hasOwnProperty(prop)) return obj[prop] else if (obj.__proto__ !== null) return getProperty(obj.__proto__, prop) else return undefined } Note: The in, for in operations will search upward the prototype chain, use hasOwnProperty as filter if needed. Every constructor function has a property prototype, which is an empty object by default. If variable x is constructed (using new) by function F, then x.__proto__ === F.prototype Here is how new works: function New (F) { var n = { '__proto__': f.prototype }; return function () { F.apply(n, arguments); return n; }; } 3. x = new f() doesn’t implement “x inherits another object”. However, Douglas Crockford found a way to exploit the new operator to do real Prototypal Inheritance! js Object.create = function (parent) { function F() {} F.prototype = parent; return new F(); }; 4. Instance object (object that is not function) don’t have prototype (undefined). This prototype has a constructor property. Whenever a constructor’s prototype is manually modified, its constructor should be maintained properly. ( to ensure the correctness of operations like this.constructor.prototype.constructor.prototype and instance of) ```js function Animal() {　　　　 this.species = “动物”;　　 } function Cat(name, color) {　　　　 this.name = name;　　　　 this.color = color;　　 } Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; var cat1 = new Cat(\"大毛\",\"黄色\"); alert(cat1.species); // 动物 ``` The code above implement that \"Cat inherit Animal\", which is actually \"cat1 inherits new Animal()\" >* Not standard: *\\_\\_proto__* is non-standard and even deprecated. Also native Object.create and Douglas Crockford implementation are not exactly equivalent. >* Not optimized: Object.create (native or custom) has not yet been as heavily optimized as the new construction. It can be up to 10 times slower. class inheritance The class keyword is introduced in ES6, but is syntactical sugar, JavaScript remains prototype-based References: Javascript – How Prototypal Inheritance really works (by vjeux) 原型继承 (by 廖雪峰) Javascript继承机制的设计思想 (by 阮一锋) Javascript面向对象编程（二）：构造函数的继承 (by 阮一锋) Prototypal inheritance "},{"created_at":"2018-01-11","tags":[],"title":"Javascript","updated_at":"2018-01-11","uuid":"7C4780D5-1D11-4BA6-9D27-4474D2238003","permalink":"/Web/Javascript.html","text":" 1. Basics scripting language (interpreted, not complied) object-oriented (inheritance, encapsulation, polymorphism) prototype-based (also called classless, prototype-oriented, or instance-based) prototype is essentially object, which can be modified dynamically, while “class” can’t dynamic-typing (type of variable are not fixed) 2. How to use it ? In order to be executed by a browser, js scripts should be used by embeding it in a html file. You can directly place js source code in html with <script> tag <script>...</script> or place it in a seperate js file then include it in the html file using <script src=\"/path/to/js\"></script> Js script can be placed anywhere in html file. Usually it is placed in <head>. Placing it at the bottom of page can avoid possible loading delay. 3. Data types JavaScript has six data types. Five data types are primitives: string number boolean null undefined symbol: (since ES2015)  A data type whose instances are unique and immutable. One type is complex: object ( includes array, function ) You can consider it a bug in JavaScript that typeof null is an object. It should be null. typeof undefined             // undefined typeof null                  // object null === undefined           // false null == undefined            // true 4. Declaration There are three types of declarations (since ES6): var: global variable or function level variable. let: block level local variable. const: read-only constant. Itself can’t be assigned while it’s properties can. Must be initialized. It’s scope is the same as ‘let’ value variables declared by ‘let’ and ‘var’ with no initial value has the value “undefined” variable scope global: declared outside of function local: declared in function function levelif (true) { var x = 5; } console.log(x);  // x is 5 block levelif (true) { let y = 5; } console.log(y);  // ReferenceError: y is not defined variable hositing and function hoisting Variables in JavaScript are in a sense “hoisted” or lifted to the top of the function or statement. However, variables that are hoisted will return a value of undefined. In ECMAScript 2015, let (const) will not hoist the variable to the top of the block. For functions, only function declaration gets hoisted to the top and not the function expression. /* Function declaration */ foo(); // \"bar\" function foo() { console.log(\"bar\"); } /* Function expression */ baz(); // TypeError: baz is not a function var baz = function() { console.log(\"bar2\"); }; global variables Global variables are in fact properties of the global object. In web pages the global object is window Javascript Notes 1. Online version of “Exploring ES6” by Dr. Axel Rauschmayer If you really want to understand ES6, you have to understand how each feature works, even when you’re dealing with unusual situations and edge cases. What sets Axel Rauschmayer’s Exploring ES6 apart from other books is that it really cares about the inner workings of ECMAScript. It doesn’t just describe the common use cases that you probably already understand. It digs deep into the semantics and, where necessary, wallows in the edge cases. It explains why features work the way that they work and how they are used in realistic code. Assimilate the material in this book and you will be an ES6 expert. 2. How do JavaScript closures work under the hood This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 3. Javascript – How Prototypal Inheritance really works (by vjeux) Other reference: 原型继承 (by 廖雪峰) Javascript继承机制的设计思想 (by 阮一锋) Javascript面向对象编程（二）：构造函数的继承 (by 阮一锋) Prototypal inheritance Javascript Notes 1. Online version of “Exploring ES6” by Dr. Axel Rauschmayer If you really want to understand ES6, you have to understand how each feature works, even when you’re dealing with unusual situations and edge cases. What sets Axel Rauschmayer’s Exploring ES6 apart from other books is that it really cares about the inner workings of ECMAScript. It doesn’t just describe the common use cases that you probably already understand. It digs deep into the semantics and, where necessary, wallows in the edge cases. It explains why features work the way that they work and how they are used in realistic code. Assimilate the material in this book and you will be an ES6 expert. 2. How do JavaScript closures work under the hood This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 3. Javascript – How Prototypal Inheritance really works (by vjeux) Other reference: 原型继承 (by 廖雪峰) Javascript继承机制的设计思想 (by 阮一锋) Javascript面向对象编程（二）：构造函数的继承 (by 阮一锋) Prototypal inheritance "},{"created_at":"2018-01-11","tags":[],"title":"Javascript Clousure","updated_at":"2018-01-11","uuid":"9B57CCEE-241E-40DC-A99F-0A59965EF0A0","permalink":"/Web/Javascript-Clousure.html","text":" Closure How do JavaScript closures work under the hood[1] This is the best article I’ve read that illustrats how “closures” works and what is going on behind the scene when they’re used. 1. scope objects Each function object has a “scope” property that points to the scope the function is defined. Whenever a function is called, a corresponding scope is created. (If same function is called multiple times, then multiple seprate scope object are created.) This new created scope object has a pointer pointing to its parent scope object, which is the scope property of the function object, resulting in a scope chain. Scope chain works as same as prototype chain, except that ReferenceError is throwed rather than undefiend is returned. Whenever there is a reference to it, a scope exists, even if the corresponding function is returned. Otherwise, it will be garbage-collected on occasion. 2. this this is not saved as a part of the scope chain. Instead, value of this depends on the “function invocation pattern”. method invocation pattern function invocation pattern constructor invocation pattern apply invocation pattern Function.prototype.apply/call/bind/ For more details on closure, also refer to [2] and [3] Dmitry Frank. How do JavaScript closures work under the hood ? ↩︎ Stackoverflow. Several excellent introductions to closures. (especially the two most voted). ↩︎ MDN. Function reference ↩︎ "},{"created_at":"2018-01-11","tags":["concurrency"],"title":"Javascript Event Loop","updated_at":"2018-01-11","uuid":"F4710703-29CF-4142-A77D-2F2C1907EAAF","permalink":"/Web/Javascript-Event-Loop.html","text":" Concurrency model and Event Loop "},{"created_at":"2018-01-11","tags":[],"title":"NodeJs","updated_at":"2018-01-11","uuid":"F9C4B9EB-0FCF-43BD-BB56-61A49AC9A37B","permalink":"/Web/NodeJs.html","text":" Node.js 1. The art of node This article expatiates asynchrous mechanism in node. It explains why node is a I/O based language. It mainly talks about “callbacks”, “events”, “modules”. “stream” is talked about in stream-handbook 2. Javascript promise, under the hood. This article illustrate how promise works by writing its own promise library squab. It clearly shows what “promise” generally looks like. 3.《深入浅出node.js》 This book explains lots of fundmental mechanism behind the scene. Packages file system fs fs-extra chokidar hexo-fs Module How does require() work ? require() 源码解读 by 阮一锋 nodejs official reference about module Require statements are executed sychronously. That is, all the statements in the required module are executed before continuing execute statements after the require statement. Required modules are cached. They can be viewed as single instance. Basic modules fs stream https path Other common modules cheerio: for jquery underscore: for underscore bluebird: for Promise Npm Install npm install installs all dependent packages (and those dependent on these packages, and…) specified in package.json. npm install <package> installs ‘package’. options: -g : install globally  (default locally in ./node_modules/) –save: save to package.json as dependency –save-dev: save to package.json as dependencyDev Others create a symlink on mac ln -s /path/to/origin /path/to/link "},{"created_at":"2018-01-02","tags":["markdown"],"title":"hackmd features","updated_at":"2018-01-10","uuid":"31EB3713-48E6-4D96-A197-2CC3AF12779A","permalink":"/Misc/hackmd-features.html","text":" Features English version 中文版 日本語版 Do not modify this note. Thank you very much  If you want to say hello or play with something, please go to Playground Introduction HackMD is a realtime, multiplatform collaborative markdown note editor. This means that you can write notes with other people on your desktop, tablet or even on the phone. You can sign-in via Facebook, Twitter, GitHub, or Dropbox in the homepage. Note that this service is still in an early stage, and thus still has some issues. Please report new issues in GitHub. If you need instant help, please send us a Facebook message. Thank you very much! Workspace Modes Desktop & Tablet Edit: See only the editor. View: See only the result. Both: See both in split view. Mobile View: See only the result. Edit: See only the editor. Image Upload: You can upload an image simply by clicking on the camera button . Alternatively, you can drag-n-drop an image into the editor. Even pasting images is possible! This will automatically upload the image to imgur, nothing to worry.  Share Notes: If you want to share an editable note, just copy the URL. If you want to share a read-only note, simply press publish button  and copy the URL. Save a Note: Currently, you can save to Dropbox  or save an .md file  locally. Import Notes: Similarly to the save feature, you can also import an .md file from Dropbox , or import content from your clipboard , and that can parse some html which might be useful  Permissions: It is possible to change the access permission to a note through the little button on the top right of the view. There are six possible options: Freely: Anyone can edit this note. Editable: A signed-in user can edit this note. Limited: People have to sign-in to view and edit this note. Locked: Anyone can view this note but only the owner can edit it. Protected: People have to sign-in to view this note but only owner can edit. Private: Only the owner can view and edit this note. Only the owner of the note can change the note’s permissions. Embed a Note: Notes can be embedded as follows: <iframe width=\"100%\" height=\"500\" src=\"https://hackmd.io/features\" frameborder=\"0\"></iframe> Slide Mode: You can use a special syntax to organize your note into slides. After that, you can use the Slide Mode  to make a presentation. Visit the above link for details. Book Mode: You can make your notes into a book. List your links in order or nest them. Then use the Book Mode  to make a collection. Visit the above link for details. View Table of Contents: You can look at the bottom right section of the view area, there is a ToC button . Pressing that button will show you a current Table of Contents, and will highlight which section you’re at. ToCs support up to three header levels. Permalink Every header will automatically add a permalink on the right side. You can hover and click  to anchor on it. Edit: Shortcut Keys: Just like Sublime text, which is pretty quick and convenient. For more infomation, see here. Auto-Complete: This editor provides full auto-complete hints in markdown. Emojis: type : to show hints. Code blocks: type ``` and plus a character to show hint. ``` Headers: type # to show hint. Referrals: type [] to show hint. Externals: type {} to show hint. Images: type ! to show hint. Title: This will take the first level 1 header as the note title. Tags: Using tags as follows, the specified tags will show in your history. tags: features cool updated YAML Metadata You can provide advanced note information to set the browser behavior (visit above link for details): robots: set web robots meta lang: set browser language dir: set text direction breaks: set to use line breaks GA: set to use Google Analytics disqus: set to use Disqus slideOptions: setup slide mode options ToC: Use the syntax [TOC] to embed table of content into your note. [TOC] Emoji You can type any emoji like this     See full emoji list here. ToDo List: ToDos Buy some salad Brush teeth Drink some water Code Block: We support many programming languages, use the auto complete function to see the entire list. var s = \"JavaScript syntax highlighting\"; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) +  ' class=\"\"'; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i < classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } If you want line numbers, type = after specifying the code block languagues. Also, you can specify the start line number. Like below, the line number starts from 101: var s = \"JavaScript syntax highlighting\"; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) +  ' class=\"\"'; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i < classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } Or you might want to continue the previous code block’s line number, use =+ var s = \"JavaScript syntax highlighting\"; alert(s); Somtimes you have a super long text without breaks. It’s time to use ! to wrap your code. When you’re a carpenter making a beautiful chest of drawers, you’re not going to use a piece of plywood on the back. Blockquote Tags: Using the syntax below to specifiy your name, time and color to vary the blockquotes. [name=ChengHan Wu] [time=Sun, Jun 28, 2015 9:59 PM] [color=#907bf7] Even support the nest blockquotes! [name=ChengHan Wu] [time=Sun, Jun 28, 2015 10:00 PM] [color=red] MathJax You can render LaTeX mathematical expressions using MathJax, as on math.stackexchange.com: The Gamma function satisfying \\(\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N\\) is via the Euler integral \\[ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. \\] \\[ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. \\] More information about LaTeX mathematical expressions here. Alert Area Yes  This is a message  Watch out  Oh No!  Typography Headers # h1 Heading ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading Horizontal Rules Typographic Replacements Enable typographer option to see result. © © ® ® ™ ™ § § ± test… test… test… test?.. test!.. !!! ??? , Remarkable – awesome “Smartypants, double quotes” ‘Smartypants, single quotes’ Emphasis This is bold text This is bold text This is italic text This is italic text Deleted text lulala Superscript: 19th Subscript: H2O Inserted text Marked text Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. Lists Unordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. feafw 332 242 2552 e2 Start numbering with offset: foo bar Code Inline code Indented code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences” Sample text here... Syntax highlighting var foo = function (bar) { return bar++; }; console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Left aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Center aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Links link text link with title Autoconverted link https://github.com/nodeca/pica Images Like links, Images also have a footnote style syntax With a reference later in the document defining the URL location: Show the image with given size Footnotes Footnote 1 link[1]. Footnote 2 link[2]. Inline footnote[3] definition. Duplicated footnote reference[2:1]. Definition Lists Term 1 Definition 1 with lazy continuation. Term 2 with inline markup Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2. Compact style: Term 1 Definition 1 Term 2 Definition 2a Definition 2b Abbreviations This is an HTML abbreviation example. It converts “HTML”, but keeps intact partial entries like “xxxHTMLyyy” and so on. Footnote can have markup and multiple paragraphs. ↩︎ Footnote text. ↩︎ ↩︎ Text of inline footnote ↩︎ "},{"created_at":"2018-01-08","tags":["markdown"],"title":"markdown features","updated_at":"2018-01-15","uuid":"4E766EBD-FCA5-4680-8827-490384C3C20A","permalink":"/Misc/markdown-features.html","text":" Features that Quiver’s markdwon does not support while hackmd does : front meta blockquote tags (time, author) code block line number anchor toc emoji ( fontawesome icons container footnote abbr deflist emphasis: mark, sup, sub, ins Features Embed a Note: Notes can be embedded as follows: <iframe width=\"100%\" height=\"500\" src=\"https://hackmd.io/features\" frameborder=\"0\"></iframe> View Table of Contents: You can look at the bottom right section of the view area, there is a ToC button . Pressing that button will show you a current Table of Contents, and will highlight which section you’re at. ToCs support up to three header levels. Permalink Every header will automatically add a permalink on the right side. You can hover and click  to anchor on it. ToC: Use the syntax [TOC] to embed table of content into your note. [TOC] Emoji You can type any emoji like this     See full emoji list here. ToDo List: ToDos Buy some salad Brush teeth Drink some water Code Block: We support many programming languages, use the auto complete function to see the entire list. var s = \"JavaScript syntax highlighting\"; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) +  ' class=\"\"'; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i < classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } If you want line numbers, type = after specifying the code block languagues. Also, you can specify the start line number. Like below, the line number starts from 101: var s = \"JavaScript syntax highlighting\"; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) +  ' class=\"\"'; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i < classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } Or you might want to continue the previous code block’s line number, use =+ var s = \"JavaScript syntax highlighting\"; alert(s); Somtimes you have a super long text without breaks. It’s time to use ! to wrap your code. When you’re a carpenter making a beautiful chest of drawers, you’re not going to use a piece of plywood on the back. MathJax You can render LaTeX mathematical expressions using MathJax, as on math.stackexchange.com: The Gamma function satisfying \\(\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N\\) is via the Euler integral \\[ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. \\] \\[ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. \\] More information about LaTeX mathematical expressions here. Alert Area Yes  This is a message  Watch out  Oh No!  Typography Headers # h1 Heading ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading Horizontal Rules Typographic Replacements Enable typographer option to see result. © © ® ® ™ ™ § § ± test… test… test… test?.. test!.. !!! ??? , Remarkable – awesome “Smartypants, double quotes” ‘Smartypants, single quotes’ Emphasis This is bold text This is bold text This is italic text This is italic text Deleted text lulala Superscript: 19th Subscript: H2O Inserted text Marked text Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. Lists Unordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. feafw 332 242 2552 e2 Start numbering with offset: foo bar Code Inline code Indented code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences” Sample text here... Syntax highlighting var foo = function (bar) { return bar++; }; console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Left aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Center aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Links link text link with title Autoconverted link https://github.com/nodeca/pica Images Like links, Images also have a footnote style syntax With a reference later in the document defining the URL location: Show the image with given size Footnotes Footnote 1 link[1]. Footnote 2 link[2]. Inline footnote[3] definition. Duplicated footnote reference[2:1]. Definition Lists Term 1 Definition 1 with lazy continuation. Term 2 with inline markup Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2. Compact style: Term 1 Definition 1 Term 2 Definition 2a Definition 2b Abbreviations This is an HTML abbreviation example. It converts “HTML”, but keeps intact partial entries like “xxxHTMLyyy” and so on. Footnote can have markup and multiple paragraphs. ↩︎ Footnote text. ↩︎ ↩︎ Text of inline footnote ↩︎ "},{"created_at":"2017-10-14","tags":[],"title":"draft","updated_at":"2018-05-09","uuid":"67CD709D-F905-4B76-944D-892DA5265F8C","permalink":"/Misc/draft.html","text":" cppmark 待考虑 tables smartypants mangle unescape line number 常见指令时间 https://zhuanlan.zhihu.com/p/30742986 羽毛球笔记： 上网步伐练习 初始位置永远是右脚稍稍在前，重心下蹲 交叉步两步上网，不要用垫步 第一步判断来球方位，不要出拍;判断好来球方位后第二步要根据击球点来跨（跨远还是跨近），跨步的同时出拍抢最高点 出拍时拍面接近于水平（有一点偏角），拍杆与前臂夹角接近90度，不要呈180度的水平夹角 击球后回退时先退一小步（并步退，保持右脚在前），准备下一拍可能的扑球。然后再退第二步，退的时候注意稍稍压低重心 "},{"created_at":"2018-05-21","tags":[],"title":"design patterns","updated_at":"2018-05-21","uuid":"787EB1FB-2612-4813-AFFA-7DD6CCDAA328","permalink":"/Misc/design-patterns.html","text":" Google研院的Peter Norvig大叔总结了23个design pattern在lisp/python等函数式语言之下的对应物。引用如下=====================================================16 of 23 patterns are either invisible or simpler, due to:  First-class types (6): Abstract-Factory, Flyweight, Factory-Method, State, Proxy, Chain-Of-Responsibility  First-class functions (4): Command, Strategy, Template-Method, Visitor  Macros (2): Interpreter, Iterator  Method Combination (2): Mediator, Observer  Multimethods (1): Builder  Modules (1): Facade =====================================================总结：Design Pattern揭露了OOP系统本身的不灵活 "},{"created_at":"2017-11-11","tags":["mutex","thread"],"title":"线程同步机制","updated_at":"2018-01-11","uuid":"D42743CE-2B9A-4F0A-A692-AEF12A090719","permalink":"/Misc/线程同步机制.html","text":" 线程基础知识 线程同步的底层支持包括： TSL （或其它）原子操作 中断服务 互斥锁Mutex 最基本的同步机制是锁（Lock），包括 互斥锁(Mutex), Read-Write 锁, 空转锁。以Mutex为例： 对Mutex状态的判断及修改是通过机器提供的原子性指令完成的。 每个Mutex上有一个等待队列（waiting list) Lock()操作在”locked” 情况下会被挂起，实际上是先空转（spin）一小会再挡土挂起（yield），当前线程会加入到Mutex的waiting list中。 挂起是指将线程置于”睡眠“状态，并调用线程调试函数切换到其它线程 Unlock() 操作会释放锁, 并且唤醒waiting list中的一个（或所有）线程。 Condition Variables pthread_join()解决的是多个线程等待同一个线程的结束。Condition variable解决的是多个线程等待某个条件发生。 Condition主要用来实现通知/同步机制，内部也是由waiting list实现。实际上Mutex也有”通知唤醒“功能，但Mutex功能过于简单，用来实现通知/同步功能时容易出问题：每个线程需要不断的试图获取Mutex锁并检查条件是否发生，从而浪费大量资源。（python的condition内部就是用多个waiter lock实现的。） Condition 一定要配合 Mutex 才能使用，因为状态的检测/改变与等待/发信操作需要具有原子性。 wait() 会自动释放Mutex, 等到被唤醒时会自动去获取Mutex notify() 会唤唤醒waiting list中的线程 检测条件状态要用while, 发信号要在临界区 Semaphore 信号量 semaphore是进程间PV，可以理解为带计数器的Condition variable Python中的Event, Queue References 操作系统如何实现mutex pthread的各种同步机制 When is a condition variable needed, isn’t a mutex enough? Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues 关于Condition Variable为什么需要一个Mutex的思考 Linux并发与同步 "},{"created_at":"2017-11-02","tags":["clrs"],"title":"references","updated_at":"2018-02-09","uuid":"084926CA-92E0-407D-9AF8-3C66E6106F43","permalink":"/Algorithm/references.html","text":" [Solutions] Introduction to algorithms, 3rd Graph Algorithm (4+3+3+5 = 10 algs) Elementary BFS DFS Topological Sort SCC MST Generic-MST Kruskal Prim SSSP Bellman-Ford SSSP-DAG Dijkstra APSP Slow-Matrix-Mulplication Faster-Matrix-Mulplication Floyd-Warshall Transitive Clousure Johnson Elementary BFS(G,s) for each v in G.V color[v] = White Q={s}    // FIFO queue while Q is not empty u = Q.pop() for each v in G.adj[u] if color[v] == White visit(v) Q.push(v) color[v] = Gray color[u] = Black    //optional DFS(G) time = 0 for each v in G.V v.color = WHITE v.pie = NIL for each v in G.V if v.color == White DFS-visit(G,v) DFS-Visit(G,u) time += 1 u.d = time u.color = GRAY   //discover u for each v in G.adj[u] if v.color == WHITE v.pie = u DFS(G,v) time = time + 1 u.f = time u.color = BLACK    //close u Topological-Sort(G) call DFS(G) to compute finishing time v.f for each vertex v as each vertex is finished, insert it into the front of a linked list return the linked list Compute-SCC(G) call DFS(G) to compute finishing time v.f for each vertex v compute G' call DFS(G'), but in the main loop of DFS, consider the vertex in order of decreasing v.f (as computed in line 1) output the vertices of each tree computed in line 3 as a seperate strong connected component Note: \\(G^{SCC}\\) is a DAG Let \\(C_1,C_2\\) be two seperate SCCs, if there exists an edge \\(e\\) from \\(C_1\\) to \\(C_2\\), then \\(f(C_1) > f(C_2)\\), i.e. \\(\\max_{v\\in C_1} v.f > \\max_{v\\in C_2} v.f\\), which implies that we’re considering components in topological order in line 3 MST G=(V,E,w) is connected Generic(G,w) A = {} while A does not form a spanning tree find an edge (u,v) that is safe for A insert (u,v) into A return A Kruskal(G,w) A = {} for each v in G.V Make-Set(v) sort G.E in nondecreaing order for each edge (u,v) in G.E, taken in nondecreaing order if Find-Set(u) != Find-Set(v) insert (u,v) into A UNION(u,v) return A Prim(G,w,r) for each v in G.V v.d = \\infty v.pie = NIL r.d = 0 Q = G.V  //min priority queue while Q is not empty u = Extract-Min(Q) for v in G.adj(u) if v.d > u.d + w(u,v) v.d = u.d + w(u,v) v.pie = u SSSP Initialize-Single-Source(G,s) for each v in G.V v.pie = NIL v.d = INFTY s.d = 0 Relax(u,v,w) if v.d > u.d + w(u,v) v.d = u.d + w(u,v) v.pie = u Bellman-Ford(G,w,s) Initialize(G,s) for i = 1 to n - 1 for each edge (u,v) in G.E Relax(u,v,w) for each edge (u,v) in G.E if v.d > u.d + w(u,v) return False return True Note: if there exists a negative cycle of length k, then at least one edge on the cycle can be truely relaxed after all vertecies of the cycle having finite distances. SSSP-DAG(G,w,s) Topological-Sort(G) Initialize-Single-Source(G,s) for each u taken in topological order for each v in G.adj[u] Relax(u,v) Dijkstra(G,w,s) Initialize(G,w,s) Q = G.V  //min priority queue  while Q is not empyt u = Extract-Min(Q) for each v in G.adj[u] Relax(u,v) APSP "},{"created_at":"2018-01-22","tags":[],"title":"CLRS Solutions (3rd)","updated_at":"2018-01-22","uuid":"39B51C85-5659-4912-B13C-18B3D69C17D5","permalink":"/Algorithm/CLRS-Solutions-(3rd).html","text":" 24.3-4 First check wheter \\((d,\\pi)\\) compose an \\(s\\)-rooted tree.(i.e. they satisfy properties 1 and 2 in page 647.) Then check that \\(d(s)=0\\) and for all \\(v\\in V\\), \\(d(v) = \\min_{u\\in N(v)}\\{d(u)+w(u,v)\\}\\) and \\(\\pi(v)\\) is the minimizer, where \\(N(v) = \\{u\\in V\\ |\\ (u,v)\\in E\\}\\). If all are true, return true, otherwise return false. It can be easily seen that the total time is \\(O(m+n)\\). Now to prove the correctness. For one direction, if \\((d,\\pi)\\) match one shortest-paths tree, our algorithm must output true. For the other direction, suppose \\((d,\\pi)\\) doesn’t match any such tree and the algorithm output true. Suppose \\(T'=(\\pi',\\delta)\\) is a shortest-paths tree. For all incorrect vertex \\(v\\), we must have \\(d(v)>\\delta(v)\\) since we can really find a path of length \\(d(v)\\) from \\(s\\) to \\(v\\) according to \\(\\pi\\). There must be at least one incorrect vertex. Let \\(v\\) be an incorrect vertex closest to \\(s\\) in \\(T'\\). Then \\(u_1=\\pi(v)\\) and \\(u_2 = \\pi'(v)\\) exist since \\(v\\) can not be \\(s\\). Therefore we have \\(d(u_1)+w(u_1,v)=d(v)>\\delta(v)=d(u_2)+w(u_2,v)\\) since \\(u_2\\) is correct, which contradicts the fact that \\(u_1\\) is the minimizer of \\(d(u)+w(u,v)\\). It seems that this algorithm works for negative edges, doesn’t it? "},{"created_at":"2018-01-07","tags":["graph"],"title":"graph","updated_at":"2018-01-15","uuid":"6838DF52-CB29-46E2-ABF9-45FFE146D985","permalink":"/Algorithm/graph.html","text":" Minimum Height Trees(MHTs) Given a tree T, find all the roots that make the minimum height. solution 1 Find any longest path, its middle point(s) is the answer. Finding a longest path can be solved in \\(O(n)\\) time by tree dp, or simply 2 tree travesal. solution 2 Use direct dp, let dp[i] be the height of the tree when the tree root is i, compute dp[0],…,dp[n - 1] by tree dp in a dfs manner. In dfs, when we reach node u, let T be the subtree by removing all u’s descendants. We also maintain a variable acc that keeps track of the length of the longest path in T with u being on end. Then we have dp[u] = max(height[u], acc). In dfs, when we move from u to its child v, then newAcc = max(acc + 1, height[v’]+2) for all other child v’ of u. We can compute it in \\(O(1)\\) time by maintaining two heights of each node u, one is the conventional height, the other is the height after removing the branch w.r.t. the convention height. solution 3 Iterately prune leaves. Use Set to denote the adjancency, compute the answer in O(n) time. Leetcode solution 1 and 2 Leetcode solution 3 "},{"created_at":"2017-11-19","tags":[],"title":"python async","updated_at":"2018-01-11","uuid":"5AC52F94-DA11-42AD-BEF6-8B1F9C571296","permalink":"/Python/python-async.html","text":" Future python 中的 Future 相当于 js 中的 Promise ，功能是把”事件发生“ 与”回调函数“ 分离。不仅可以先注册callback, 等“事件发生”（Future中是set_result, js中是resolve)后自动调用一个或多个callback; 还可以在 set_result后在注册callback. 内部通过保存”事件发生“这一状态来实现 Deferred 效果。 Select python中的select module中有针对不同平台的系统函数来完成IO复用的功能，最原始的是select函数, 在大多数平台上都有。poll比 select更优化一些，本质上差不多。只存在于linux上的epoll 以及 BSD 上的 kqueue，windows上的IOCP, Solaris上的devpoll 则更加优化和强大。其中IOCP是真正的异步，不存在阻塞，其它或多或少有一点阻塞，epoll和kqueue在性能上基本上更真正的异步差不多，devpoll不太清楚。 这些类select函数根据平台的不同，有的只支持sockets（IOCP), 有的还支持pipe( epoll ) 或其它file-like objects. 有的只能监听到readable/writable/error, 有的能精确区分更复杂的事件。epoll 有水平（level）触发和边沿（edge)触发。 python中的selectors module (相当于nodejs中隐含在内部的libuv库） 则将这些不同的select函数抽象成一个统一的接口，用户只需要用DefaultSelector 来获得当前平台下最适合的select。这些类select主要实现以下功能 register(fileobj, events, data=Non): 注册fileobj 以及需要监听的事件 unregister(fileobj): 注销 modify(fileobj, events, data=Non): 更改 select(timeout=None): 返回有”事件发生“的(key, events) list, 其中的key 为SectorKey类，包含fileobj, fd, events, data。该方法会根据timeout的值进行阻塞或非阻塞调用。其内部原理比较复杂，大致是结合了中断和轮询来实现的。 epoll详细工作原理 asyncio 有了python的callback机制，以及select module, 我们已经可以手写地实现python中的异步功能。但是，这样写会很麻烦，代码不易读。于是就有了各种第三方库来简化，如 Tornado, Twisted, Gevent, Eventlet, greenlet等。从3.4开始, python引入了标准库 asyncio. greenlet （比较低级，一般用来构建其它库） Eventlet (基于IO复用和coroutine, 相当于implictly调用coroutine, 不需要像coroutine那样explictly切换控制流) Gevent (与Eventlet类似，但功能更强大） Twisted（面向对象，基于事件驱动的网络库，比较低级） Tornado (作为一个web框架和异步网络库使用，同样基于IO复用和coroutine） async实现了许多功能，要理解它的话需要理解以下几个关键的东西：coroutine, Task, event_loop Coroutine coroutine是通过将Future与generator结合实现的, 其核心在于： 通过yield一个Future将该运行中的coroutine控制流”挂起“ ，相当于thread中的sleep。然而这里是通过generator的机制来保存其运行中间状态，而不是thread中的context switch. 这样不仅比thread节省时间和空间资源，还能减少绝大多数的data race. 因为这里的控制流只在yield处才会被挂起，而thread的挂起是由内核决定的，可发生的任意时候（除非加锁，disable中断）。因些coroutne某种意义上可看作green thread(轻量级线程） 在需要的时候（例如Task中），通过send将某个coroutine唤醒 coroutine 的好处在于可以将异步流用同步的方式来写。 Task以下是Task的一个简化版 class Task: def __init__(self, coro): self.coro = coro f = Future() f.set_result(None) self.step(f) def step(self, future): try: next_future = self.coro.send(future.result) except StopIteration: return next_future.add_done_callback(self.step) 每构造一个Task, 其中的coroutine就会执行，一直到yield处”挂起“，并返回一个Future。等到Future被set_result后，该coroutine又会被”唤醒“。其中Future的set_result是由select来完成的。 Event_looprun_until_complete函数接收一个或多个Task对象（若是Future的话，会自动包装生成Task)，直至所有的Task返回。这些Task的”用户代码“ 可以看作是运行在单线程中，而IO操作是通过select功能得到复用。 class EventLoop: def run_until_complete(self, coro): \"\"\"Run until the coroutine is done.\"\"\" task = Task(coro) task.add_done_callback(stop_callback) try: self.run_forever() except StopError: pass class StopError(BaseException): \"\"\"Raised to stop the event loop.\"\"\" def stop_callback(future): raise StopError 有了coroutine, Task, Event_loop 后，我们还需要自己写select的注册/注销/返回事件 等操作，register写在yield前，unregister写在yield后。但是一些支持异步的库会自动实现这两步，不需要手动来写。例如aiohttp. selector.select()函数的调用也不需要手写，个人猜测是event_loop自动开了这样一个coroutine (或thread)运行。 while True: events = selector.select() for event_key, event_mask in events: callback = event_key.data callback(event_key, event_mask) "},{"created_at":"2017-11-08","tags":[],"title":"python 杂记","updated_at":"2018-01-11","uuid":"94DF2255-40B4-457D-8746-C50091A1C27C","permalink":"/Python/python-杂记.html","text":" types分类 immutable: number, string, tuple mutable: list, dict, class-object Function arguments are passed by values: immutable objects are copied by value, while mutable objects are copied by aliasing. classes themselves are objects. Iterable, Iterator, Generator Iterable: implementing iter() to return an iterator. Iterator: implementing next() and using StopIteration to indicate the end of iteration. Generator: a function returning an iterator. Thread Lock 即 Mutex, RLock 是一种特殊的Lock, 在同一线程中可多次获取（需多次释放），支持 acquire() 和 release() Condition是由一个主Lock (可以是RLock)和若干个 Waiter Lock 组成，除acquire(), release()外还支持wait(), notify() Semaphore 是带counter的Condition Event是Condition的一个adaptor，支持set(), wait(), clear() Queue 是由若干个Contiiton实现的queue, 支持 put(), get(), task_done(), join() Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues Understanding Asynchronous IO With Python 3.4’s Asyncio And Node.js Python 开源异步并发框架的未来 (2014年4月) "},{"created_at":"2017-11-17","tags":["python","网络"],"title":"python 网络编程","updated_at":"2017-11-17","uuid":"DB449EBD-23A8-43E0-90E2-AB5A31317B3B","permalink":"/Python/python-网络编程.html","text":" 杂记：网卡一般是双工的，上行下行可同时发生，传输是以字节Byte为最小单位（本质上传输的是比特流）。 "},{"created_at":"2018-01-11","tags":[],"title":"Gu Yong","updated_at":"2018-01-11","uuid":"1D0023BA-2C94-4DD2-8CB4-60958845E043","permalink":"/404.html","text":" 404 Page Not Exist Home Misc | Algorithm | Research |  "},{"created_at":"2018-01-11","tags":[],"title":"Gu Yong","updated_at":"2018-01-11","uuid":"BFEA3417-C38B-4320-B4A9-C1CC55F30D8C","permalink":"/Stickers.html","text":" Keep writing, reviewing, exercising, thinking. 2017-08-23 透过表象看本质，抓住本质找规律，运用规律改变世界 "},{"created_at":"2018-06-02","tags":[],"title":"Graph Theory","updated_at":"2018-06-02","uuid":"A591B945-C103-4897-A9A9-EAD22E3947B4","permalink":"/Research/Graph-Theory.html","text":" Graph theory Courses Theory of Algorithms by Robert Tarjan  Matching Definition and theorems alternating path, augmenting path, blossom, blossom lemma, Berge theorem Results Unweighted, bipartite augmenting path \\(O(mn)\\) Hopcroft-Karp algorithm \\(O(\\sqrt{n}m)\\) Unweighted, general Edmonds method (blossom shinking)   \\(\\quad O(mn^2)\\quad O(nm\\alpha(m,\\lceil m/n\\rceil))\\) Lectures and Papers Matching algorithms Includes augmenting path, Hopcroft-Karp algorithm, Edmonds method. Algorithms and proofs as well as the definition and lemma of blossom is more clear. Graph matching nonbipartite matching Includes Edmonds method, explains why bolssom shirking is needed in general graph. In DFS, a node may be encountered both in odd and even position. It’s necessary to record both of the two kinds of visited label. Otherwise, feasible augmenting path may exists but not found. However, if the algorithm distinguish the two kinds of visited label, odd length cycle may exists in a found path. Therefore, blossom shirking is needed. 2-Matching Definitions and Theorems b-matching, capacitated b-matching, 2-factors, \\(C_k\\)-free, TSP Definitions and Theorems Results "},{"created_at":"2018-01-20","tags":[],"title":"writing","updated_at":"2018-05-21","uuid":"6A8D1322-8E6E-4CAD-88DF-EBF00930FD1A","permalink":"/English/writing.html","text":" To simplify the ensuing presentation, …Had there been that if … "},{"created_at":"2018-01-11","tags":[],"title":"Words and Phrases","updated_at":"2018-01-11","uuid":"8F1B8E0D-438D-4169-8182-CF1C19DB374C","permalink":"/English/Words-and-Phrases.html","text":" 词汇与短语笔记 in the wake of “在…之后，紧跟” all in all “总之” “Not choice, but habit rules the unreflecting herd.” William Wordsworth said in the 19th century. 1）unreflecting 意为“缺乏思考的”。2) herd 常见意思是“畜群，牧群”，这里指“民众，百姓”，常含贬义。 Among the most popular: paternity and kinship testing. Which adopted children can use to find their biological relatives and families can use to track down kids put up for adoption. 1） track down 意思是“跟踪找到，追查到”。2) put up for adoption 指“将…送给别人收养”。 To take this approach to the New Englanders normally means to start with the Puritan’s theological innovations and their distinctive ideas about the church—important subjects that we may not neglect. 【译文】以这种方法看待新英格兰人通常意味着要从这些清教徒的神学变革和他们关于教堂的与众不同的理念入手——这些是我们不容忽视的重要主题。 【点拨】 动词短语 take a/an …approach to sth.意思是“对…采用…方法/态度”。 Copyright rested with the journal publisher, and researchers seeking knowledge of the results would have to subscribe to the journal. 【译文】论文的版权归杂志社所有，要想查阅此研究成果的研究者必须订阅该杂志。 【点拨】rest 通常情况下作名词，意为“休息”或“剩余部分”。在本句中，rest 为不及物动词，意为“归于；在于”，此时常与 with 连用。 The report, by John Houghton of victoria University in Australia and Graham Vickery of the OECO,makes heavy reading for publishers who have, so far, made handsome profits. 【译文】这份澳大利亚维多利亚大学的约翰·霍顿和“经合组织”的格雷厄姆·维克瑞共同撰写的报告让那些迄今为止获取了巨大利润的出版商们读起来心情沉重。 【点拨】1） make heavy reading for 在句中是指报告让出版商们“读起来心情沉重”。2) handsome 原意为“英俊的”，但在本句中意为“（收入、收益等）可观的，丰厚的。” by and large 意为“总的来说；大体上” Scholars, policymakers, and critics of all stripes have debated the social implications of these changes,but few have looked at the side effect: family risk has risen as well. 【译文】学者、政策制定者以及形形色色的评论家就这些变化的社会意义展开了讨论，但是却很少有人看到其副作用；家庭风险也提高了。 trade A for B  用A交换B Left, until now, to odd, low-level IT staff to put right, and seen as a concern only of data-rich industries such as banking, telecoms and air travel, information protection is now high on the boss’s agenda in businesses of very variety. 【译文】在这之前，信息保护通常还只是临时的、低层次的信息技术员的工作，并且只被诸如银行、电信、航空公司等数据量大的行业重视，可现在这个问题被放在了各行各业老板的议事日程的重要位置。 "},{"created_at":"2018-01-11","tags":[],"title":"Mood","updated_at":"2018-01-11","uuid":"DE09059E-8BFE-4567-B219-AACF81C0C487","permalink":"/English/Mood.html","text":" 语气（Moods） 语气是利用动词变化来表达“真、假”口吻的方式。依各种不同程度的“真、假”口吻，可以细分为四种语气： 叙述事实语气（Indicative）：表示所说的是真的 条件语气（Conditional）：表示真假还不能确定 假设语气（Subjunctive）：说反话，表示所说的与事实相反 祈使语气（Imperative）：表示希望能成真，但尚未实现 叙述事实语气 一般的英语句子都是这种语气，在时态部分所学的现在式、过去式、未来式等等也都是属于叙述事实语气，所以不必多作解释。其中只有未来式要说明一下： I’ll go to the U.S. next year to study for an MBA degree. 现在、过去的事情，真假已经可以确定，所以用叙述事实语气。未来的事情还没有发生，严格说起来还不能确定真假，所以未来式中动词要加上助动词 will, 因为助动词都带有不确定的语气。 The weatherman says sunrise tomorrow is at 5:32. The movie starts in 5 minutes. 虽然还没有发生，但是由于所描述的事在某种程度上可以视为“确定的事实”，不必加上表示不确定性的助动词。 I’ll be ready when he comes. If you are late again, you’ll be fired. 同时叙述两件未来的事性，而两者之间有时间或条件的关联性时，往往其中一件（副词从句中的那句）要改成现在式。这是因为两件未来的事情都不确定，需要先假定其中一件是事实已经发生，才能去推论另一件事。 条件语气 句子中一旦加上语气助动词（如 must, should, will/would, may/might, can/could 等），就产生了不确定的语气，称为条件语气。有两点需要注意： 表达时间功能的不完整性 语气助动词中，must 和 should 这两个词在拼法上没有变化。至于 will/would, may/might, can/could 这三对虽然拼法有变化，可是并不表示时间，而是语气的变化：每一对的后者比前者更不确定。 语气助动词，不论是must这一类，还是can/could这一类，都无法明确表达过去式。助动词后面要用动词原形，同样缺乏时间变化，所以语气助动词需要寻找另一种特别的方式来表达过去时间。 用完成式表达对过去的猜测 语气助动词用来猜测过去的事情时，因为缺乏表达过去时间的能力，所以要借助完成式来表达。例如： It may rain any minute now.  (对现在、未来的猜测) It may have rained a little last night. （对过去的猜测） 假设语气 这是一种“说反话”的语气，表示所说的话和事实相反。这种语气是以动词的过去形态作为表达“非事实”的手段。 现在时间 If I were you, I wouldn’t do it. 假设语气是用动词的过去形态来表示”非事实“，因此用 I were you 来表示。连带在主句中也用过去形态（不代表过去时间）的 would 来表示非事实。 过去时间 If I had known earlier, I might have done something. 句子描述的时间本来就是过去时间，要用过去形态来表示”非事实“，就必须用过去完成形态 had known. 同样，主句中也要用过去完成形态（注意区分过去完成时） might have done. 其中 might 是过去形态， have done 是完成式。 未来时间 If an asteroid should hit the earth, man could die out. 这是未来的事情，严格说起来还不能确定，但是发生的可能性甚低，所以可以用非事实语气来叙述。条件从句中用过去形态但不代表过去式的 should hit 来表示非事实，主句中也是用 could die 来表示非事实。 如果是绝无可能发生的事，还有另一种表达方式： If I were to take the bribe, I could never look at other people in the eye again. 用 be going to 的过去形态 were to 来表示未来也绝不会去做。 如果用的是 should， 语气就比较松动，表示应无发生的可能但不排除万一。 以上三种时间的鸡窝，有些地方值得进一步了解一下： 句型的规律性 因为假设语气的句子是用过去形态来表示非事实，所以动词看起来都是过去形态。从以上例子可以看出，主句中都有过去式的语气助词（would, might, could). 这是因为这些句子都是在表达在一个假定的条件（非事实）下“就会”、“就可能”、“就能“有什么结果（也是非事实），所以假设语气的主句中都会有过去拼法的助动词存在。 在假设语气的条件从句中，表示现在时间和过去时间的都没有助动词存在，这是因为要先把假设的条件当真，不能用表示不确定性的助动词。只有未来时间无法排除不确定性，所以用 should 来表示可能性极小的情况，绝无可能的状况用 were to 来表示。这是条件从句中唯一会见到助动词的地方。 动词的规律性 假设语气的动词都是以过去形态来表示非事实，若是现在时间就退后成过去形态，过去时间也就退后成为过去完成形态，而未来时间则是主从句都用过去拼法的助动词来表示。 混合时间的变化 If I had studied harder in school, I could qualify for the job now. 混合真假的变化 I could have contributed to the fund dirve then, only that I didn’t have any money with me. 句型的变化 假设语气的句型很可能不是规规矩矩的“条件从句＋主句”的形态。例如： It’s time kids were in bed. If only I had more time! 祈使语气 祈使语气可视为是条件语气中，省略助动词来表示“希望能成真，但尚未实现”。例如： Come in! 可视为 You may come in! 的省略。 一般语法书上列出一些规则，如： It is necessary that… I insist that… 这些句型后面要用原形动词。其实这就是一种命令句，所以把它称为“间接命令句”，放在祈使语气中来介绍。 "}]